# Requires PySkein
# Reads the test.tsv file (and keys.tsv) generated by the Titan Secure Volume test program,
# and verifies that it is correct.
from skein import threefish
from hashlib import sha256
from binascii import hexlify
import hmac
import struct


ENCRYPTION_BLOCK_SIZE = 64
MAC_TAG_SIZE = 32
TEST_COUNT = 2048
seed = (0x29C90C34, 0x460445AC, 0xFFFFFFFF, 0x05841428)


def xor128 (state):
	t = state[0] ^ (state[0] << 11) & 0xFFFFFFFF;
	state[0] = state[1]; state[1] = state[2]; state[2] = state[3];
	state[3] = state[3] ^ (state[3] >> 19) ^ t ^ (t >> 8)

	return state[3]


def roundup (num, mod):
	assert mod != 0, "Bad mod in roundup."

	if num % mod == 0:
		return num

	extra = mod - (num % mod)

	return num + extra


def authenticate_chunk (data, mac_tag, mac_key, sector_num):
	calculated = hmac.new (mac_key, data + struct.pack ('<I', sector_num), sha256).digest ()

	return calculated == mac_tag


def decrypt_chunk (data, encryption_key, sector_num):
	result = b""

	for i in range (len (data) // ENCRYPTION_BLOCK_SIZE):
		block = data[i*ENCRYPTION_BLOCK_SIZE:(i+1)*ENCRYPTION_BLOCK_SIZE]

		tweak = struct.pack ("<QQ", sector_num, i)
		result += threefish (encryption_key, tweak).decrypt_block (block)
	
	return result


# Read keys
with open ('keys.tsv', 'rb') as f:
	mac_key = f.read (64)
	encryption_key = f.read (64)

assert len (mac_key) == 64, "Incomplete keys.tsv"
assert len (encryption_key) == 64, "Incomplete keys.tsv"


# Read volume into memory
with open ('test.tsv', 'rb') as f:
	volume = f.read ()


# Read header
header = volume[:64]
header_mac = volume[64:96]

# Authenticate header
assert authenticate_chunk (header, header_mac, mac_key, 0), "Bad Header MAC"

# Decrypt
header = decrypt_chunk (header, encryption_key, 0)

# Parse header
magic, version, ciphersuite, physical_block_size, sector_size, sector_count = struct.unpack ("<8sH32sIII10x", header)

# Validate
assert magic == b"TITANTSV", "Invalid header"
assert version == 0x0100, "Invalid header"
assert ciphersuite == b"Threefish-512-XTS-HMAC-SHA-256\x00\x00", "Invalid ciphersuite: %s" % ciphersuite
assert physical_block_size != 0, "Invalid header"
assert sector_size != 0, "Invalid header"
assert sector_count != 0xFFFFFFFF, "Invalid header"
assert (sector_size % physical_block_size) == 0, "Invalid header"
assert (sector_size % ENCRYPTION_BLOCK_SIZE) == 0, "Invalid header"

# Parse the rest of the data
padded_header_size = roundup (len (header) + len (header_mac), physical_block_size)
mac_table_size = sector_count * MAC_TAG_SIZE
mac_table_padding = roundup (mac_table_size, physical_block_size) - mac_table_size

volume = volume[padded_header_size:]
mac_table = volume[:mac_table_size]
volume = volume[mac_table_size+mac_table_padding:]

mac_table = [mac_table[i:i+MAC_TAG_SIZE] for i in range (0, mac_table_size, MAC_TAG_SIZE)]
sectors = [volume[i:i+sector_size] for i in range (0, len (volume), sector_size)]

# Authenticate and decrypt all sectors, and build a flat volume from them
volume = b""

for sector_num, sector in enumerate (sectors):
	mac_tag = mac_table[sector_num]

	assert authenticate_chunk (sector, mac_tag, mac_key, sector_num + 1), "Bad Sector MAC"

	volume += decrypt_chunk (sector, encryption_key, sector_num + 1)


# Generate expected data
expected = bytearray (b"\x00" * sector_size * sector_count)
prng = list (seed)

for i in range (TEST_COUNT):
	address = xor128 (prng) % (sector_size * sector_count)
	length = xor128 (prng) & 0xFFFF
	max_length = len (expected) - address

	length = min (length, max_length)

	for j in range (length):
		expected[address+j] = xor128 (prng) & 0xFF

# Verify data
prng = list (seed)

for i in range (TEST_COUNT):
	address = xor128 (prng) % (sector_size * sector_count)
	length = xor128 (prng) & 0xFFFF
	max_length = len (expected) - address

	length = min (length, max_length)

	for j in range (length):
		assert volume[address+j] == expected[address+j], "Invalid data stored"
		xor128 (prng)

print ("PASSED")
